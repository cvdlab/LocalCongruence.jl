var documenterSearchIndex = {"docs":
[{"location":"verticesCongruence/#.1-Vertices-Congruence-Algorithm-1","page":"4.1 - Vertices Congruence","title":"4.1 - Vertices Congruence Algorithm","text":"","category":"section"},{"location":"verticesCongruence/#","page":"4.1 - Vertices Congruence","title":"4.1 - Vertices Congruence","text":"The Vertices congruence is the base of the Cell Congruence Enabling Algorithm.","category":"page"},{"location":"verticesCongruence/#","page":"4.1 - Vertices Congruence","title":"4.1 - Vertices Congruence","text":"The merging procedure relies on the fact that points closed enought are actually the same point. This highlights the dichotomical relation between geometry and topology within a model: space location (Geometry) is needed in order to retrieve wich point to merge and consequently update the chain complexes (Topology).","category":"page"},{"location":"verticesCongruence/#","page":"4.1 - Vertices Congruence","title":"4.1 - Vertices Congruence","text":"The following interface allows close point recognition.","category":"page"},{"location":"verticesCongruence/#","page":"4.1 - Vertices Congruence","title":"4.1 - Vertices Congruence","text":"LC.vertCongruence","category":"page"},{"location":"verticesCongruence/#LocalCongruence.vertCongruence","page":"4.1 - Vertices Congruence","title":"LocalCongruence.vertCongruence","text":"vertCongruence(V::Lar.Array{Float64,2}; ϵ=1e-6)::Tuple{Lar.Points, Array{Array{Int,1},1}}\n\nEvaluates the Vertex Congruence for 3D-points V  ℳ(3n).\n\nThe function determines the points of V closer than ϵ and builds a new Vertex Set made of the representative of each point cluster.\n\nThe method returns:\n\nthe new Vertex Set\na map that, for every new vertex, identifies the old vertices it is made of\n\n\n\n\n\n","category":"function"},{"location":"verticesCongruence/#","page":"4.1 - Vertices Congruence","title":"4.1 - Vertices Congruence","text":"The value epsilon  0 actually serve as a discriminant for well understending whether different points are actually the same. As a side effect it also sets the resolution employed by the CCE algorithm itself since, even if points within the resolution where different at first glance, they arise to be the same after this procedure.","category":"page"},{"location":"verticesCongruence/#","page":"4.1 - Vertices Congruence","title":"4.1 - Vertices Congruence","text":"Do note that this powerful feature may actually cause loss in the topological structure: low resolution processing decrease in fact further steps computation complexity at the cost of a information loss.","category":"page"},{"location":"verticesCongruence/#","page":"4.1 - Vertices Congruence","title":"4.1 - Vertices Congruence","text":"In order to keep the complex as similar as possible to the input, each points class is identified as the mean point of the set.","category":"page"},{"location":"verticesCongruence/#","page":"4.1 - Vertices Congruence","title":"4.1 - Vertices Congruence","text":"We employ a KDTree structure in order to speedup the point scan; this however means that if points are supplied in different order, a different geometrical pattern may be generated (even a diffent number of points)","category":"page"},{"location":"verticesCongruence/#","page":"4.1 - Vertices Congruence","title":"4.1 - Vertices Congruence","text":"err = 1e-8\nV = [\n    0.0  err  0.0 -err  0.0  0.0\n    0.0  0.0  err  0.0 -err  0.0\n]\n\nvertCongruence(V[:, 1:5])\n\nvertCongruence(V[:, 2:6])","category":"page"},{"location":"verticesCongruence/#","page":"4.1 - Vertices Congruence","title":"4.1 - Vertices Congruence","text":"<!– add picture –>","category":"page"},{"location":"theory/#About-Complexes-and-Chain-Operators-1","page":"2 - Complexes and Chain Operators","title":"2 - About Complexes and Chain Operators","text":"","category":"section"},{"location":"example_3/#.3-1","page":"5.3 - ...","title":"5.3","text":"","category":"section"},{"location":"example_1/#.1-1","page":"5.1 - Cube Grids","title":"5.1","text":"","category":"section"},{"location":"example_2/#.2-1","page":"5.2 - ...","title":"5.2","text":"","category":"section"},{"location":"authors/#A-Authors-1","page":"A - About the Authors","title":"A - Authors","text":"","category":"section"},{"location":"authors/#","page":"A - About the Authors","title":"A - About the Authors","text":"This repository is developed and mantained by the Computational Visual Design Laboratory (CVDLAB) of Università degli Studi di Roma Tre.","category":"page"},{"location":"authors/#[Gianmaria-Del-Monte](https://github.com/gmgigi96)-1","page":"A - About the Authors","title":"Gianmaria Del Monte","text":"","category":"section"},{"location":"authors/#[Elia-Onofri](https://github.com/eOnofri04)-1","page":"A - About the Authors","title":"Elia Onofri","text":"","category":"section"},{"location":"authors/#","page":"A - About the Authors","title":"A - About the Authors","text":"Applied Mathematics in Computer Security represents my main field of interest. In particular I am mostly interested in Cryptography (from a theoretical point of view) and Cryptanalysis (from a computer science point of view).","category":"page"},{"location":"authors/#","page":"A - About the Authors","title":"A - About the Authors","text":"During my education I have also studied many field about Computer Science that vary from the Computability and Complexity Analysis to the most recent logical theories (like lambda-calculus, Linear Logic, . . . ).","category":"page"},{"location":"authors/#","page":"A - About the Authors","title":"A - About the Authors","text":"More recently I have broaden my horizons by confront myself with new perspectives of the Applied Mathematics like Graph Theory, Machine Learning, Computational Topology and Big Data Analysis.","category":"page"},{"location":"authors/#","page":"A - About the Authors","title":"A - About the Authors","text":"Linkedin","category":"page"},{"location":"authors/#[Giorgio-Scorzelli](https://www.sci.utah.edu/people/scrgiorgio.html)-1","page":"A - About the Authors","title":"Giorgio Scorzelli","text":"","category":"section"},{"location":"authors/#[Alberto-Paoluzzi](http://paoluzzi.dia.uniroma3.it/)-1","page":"A - About the Authors","title":"Alberto Paoluzzi","text":"","category":"section"},{"location":"graph_blas/#Introduction-to-GraphBLAS-Framework-1","page":"3 - GraphBLAS Introduction","title":"3 - Introduction to GraphBLAS Framework","text":"","category":"section"},{"location":"graph_blas/#","page":"3 - GraphBLAS Introduction","title":"3 - GraphBLAS Introduction","text":"GraphBLAS is an API that defines a set of sparse matrix operation based on an algebra of semirings and designed to do computation on graphs.","category":"page"},{"location":"graph_blas/#","page":"3 - GraphBLAS Introduction","title":"3 - GraphBLAS Introduction","text":"Local congruence of Chain Complexes extends GraphBLAS domain from graphs to cellular complexes.","category":"page"},{"location":"graph_blas/#","page":"3 - GraphBLAS Introduction","title":"3 - GraphBLAS Introduction","text":"An interface to SuiteSparse:GraphBLAS C library for Julia is provided by two library: SuiteSparseGraphBLAS.jl and GraphBLASInterface.jl.","category":"page"},{"location":"graph_blas/#","page":"3 - GraphBLAS Introduction","title":"3 - GraphBLAS Introduction","text":"Each GraphBLAS function operates on a semiring S = langle D_out D_in1 D_in2 bigoplus bigotimes 0 rangle, defined by three domains D_out D_in1 D_in2, two binary operators, a commutative and an associative additive operation bigoplus  D_out x D_out rightarrow D_out and a multiplicative operation bigotimes  D_in1 x D_in2 rightarrow D_out, and an identity element 0 in D_out, that satisfies the following two conditions in their respective domains:","category":"page"},{"location":"graph_blas/#","page":"3 - GraphBLAS Introduction","title":"3 - GraphBLAS Introduction","text":"Additive identity: a bigoplus 0 = a\nMultiplicative annihilation: a bigotimes 0 = 0","category":"page"},{"location":"graph_blas/#","page":"3 - GraphBLAS Introduction","title":"3 - GraphBLAS Introduction","text":"A single domain D, together with an associative operation bigodot  D x D rightarrow D and an identity element 0 in D define a GraphBLAS monoid.","category":"page"},{"location":"graph_blas/#","page":"3 - GraphBLAS Introduction","title":"3 - GraphBLAS Introduction","text":"It is possible to create a monoid with a binary operator and an identity value, and a semiring with a monoid and a binary operator.","category":"page"},{"location":"graph_blas/#","page":"3 - GraphBLAS Introduction","title":"3 - GraphBLAS Introduction","text":"With monoid and semirings, in GraphBLAS you can override the normal plus and times operators in matrices multiplications, in order to define complex algorithm in the language of linear algebra.","category":"page"},{"location":"bibliography/#B-The-Bibliography-1","page":"B - Bibliography","title":"B - The Bibliography","text":"","category":"section"},{"location":"chainComplexCongruence/#.2-Chain-Complex-Congruence-1","page":"4.2 - Chain Complex Congruence","title":"4.2 - Chain Complex Congruence","text":"","category":"section"},{"location":"chainComplexCongruence/#","page":"4.2 - Chain Complex Congruence","title":"4.2 - Chain Complex Congruence","text":"Once the Geometry of the model has been arranged, Topology must be updated as well. As from Lar standards Topology is managed as Cochain Operators","category":"page"},{"location":"chainComplexCongruence/#","page":"4.2 - Chain Complex Congruence","title":"4.2 - Chain Complex Congruence","text":"vertCongruence() method provides both the new Geometry set and the map that maps old vertices in newly born ones. This is what we refer to lower_order_classes w.r.t. Delta_0, the 1-Cochain operator matrix (in short lo_cls). This map, built as a Julia Array{Array{Int,1},1}, is needed when building delta_0. In particular, the cellCongruence() for Delta_k produces both delta_k and a map for cell classes that behaves like the one produced by vertCongruence(): this way the same method can be employed iterativelly over all the Cochain Operators, from the lowest degree up to the hihest.","category":"page"},{"location":"chainComplexCongruence/#","page":"4.2 - Chain Complex Congruence","title":"4.2 - Chain Complex Congruence","text":"Under general setting, given a Cochain operator Delta_k  C_k-1 to C_k and a lo_cls map steps are needed:","category":"page"},{"location":"chainComplexCongruence/#","page":"4.2 - Chain Complex Congruence","title":"4.2 - Chain Complex Congruence","text":"C_k-1 cells are identified with their new representative index","category":"page"},{"location":"chainComplexCongruence/#","page":"4.2 - Chain Complex Congruence","title":"4.2 - Chain Complex Congruence","text":"according the mapping lo_cls.","category":"page"},{"location":"chainComplexCongruence/#","page":"4.2 - Chain Complex Congruence","title":"4.2 - Chain Complex Congruence","text":"C_k cells are purged from duplicates cells C_k-1.","category":"page"},{"location":"chainComplexCongruence/#","page":"4.2 - Chain Complex Congruence","title":"4.2 - Chain Complex Congruence","text":"If this occurres then the corresponding cell topology has changed and this\nfollows from low resolution problems.\n* If a cell results in having less than ``k + 2`` elements, then it is\n  discarded since it has been assimilated in lower order cells. \n* Due to low resolution problems topological gift wrapping (TGW) algorithm\n  may be required on ``\\{C_k\\}_{k>1}`` since new cell may have been formed.","category":"page"},{"location":"chainComplexCongruence/#","page":"4.2 - Chain Complex Congruence","title":"4.2 - Chain Complex Congruence","text":"C_k cells are compared and duplicates are removed.\nA map ho_cls (we refer to it as higher order in contrast with lo_cls)","category":"page"},{"location":"chainComplexCongruence/#","page":"4.2 - Chain Complex Congruence","title":"4.2 - Chain Complex Congruence","text":"between ``C_k`` of ``[\\Delta_k]`` and the survivors from previous step\nis built.","category":"page"},{"location":"chainComplexCongruence/#","page":"4.2 - Chain Complex Congruence","title":"4.2 - Chain Complex Congruence","text":"In the original use case of the Arrangment pipeline the Cochain Operator Matrices Delta_k providden as input have values accumulated on the diagonal as shown in Figure 1. In this case string conditions are likelly to be required: e.g. only points from diffenet complexes are possibly merged.","category":"page"},{"location":"chainComplexCongruence/#","page":"4.2 - Chain Complex Congruence","title":"4.2 - Chain Complex Congruence","text":"(Image: )","category":"page"},{"location":"chainComplexCongruence/#","page":"4.2 - Chain Complex Congruence","title":"4.2 - Chain Complex Congruence","text":"Figure 1: Doubly nested structure of sparse block-matrices Delta_k  C_k-1 to C_k. Here light gray portions identify the originally arranged complexes that are merged toghether. Dark grey portions are instead the cells within the same complex and are the only portions where values are stored.","category":"page"},{"location":"chainComplexCongruence/#","page":"4.2 - Chain Complex Congruence","title":"4.2 - Chain Complex Congruence","text":"Three implementation are provided in this package.","category":"page"},{"location":"chainComplexCongruence/#","page":"4.2 - Chain Complex Congruence","title":"4.2 - Chain Complex Congruence","text":"## 5.2.1 - Array of Array based implementation","category":"page"},{"location":"chainComplexCongruence/#","page":"4.2 - Chain Complex Congruence","title":"4.2 - Chain Complex Congruence","text":"LC.cellCongruenceAA","category":"page"},{"location":"chainComplexCongruence/#","page":"4.2 - Chain Complex Congruence","title":"4.2 - Chain Complex Congruence","text":"## 5.2.2 - Native Julia Sparse Matrices based implementation","category":"page"},{"location":"chainComplexCongruence/#","page":"4.2 - Chain Complex Congruence","title":"4.2 - Chain Complex Congruence","text":"LC.cellCongruenceSM","category":"page"},{"location":"chainComplexCongruence/#LocalCongruence.cellCongruenceSM","page":"4.2 - Chain Complex Congruence","title":"LocalCongruence.cellCongruenceSM","text":"cellCongruenceSM(\n\tcop::Lar.ChainOp,\n\tlo_cls::Array{Array{Int,1},1},\n\tlo_sign::Array{Array{Int8,1},1};\n\timp = false,\n\td = 0\n)::Tuple{ Lar.ChainOp,  Array{Array{Int,1},1},  Array{Array{Int8,1},1} }\n\nEvaluates the Cell Congruence for a Cochain cop with classes lo_cls.\n\nThe function determines the new Cochain Operator built from cop where the lower order cells are merged according to lo_cls map. lo_sign specifies whether a cell must be considered in reverse order.\n\nIf optional paramenter imp is set to true then FP imprecisions are taken into account in the sense that lower order cells may have collided. The parameter d represent then the order of the cell (that also is the least number of lower order cells a current order cell is made of).\n\nThe method returns:\n\nthe new Cochain Operator\na map that, for every new cell, identifies the old cells it is made of\na map that, for every new cell, specify if old cells have changed ordering.\n\n\n\n\n\n","category":"function"},{"location":"chainComplexCongruence/#","page":"4.2 - Chain Complex Congruence","title":"4.2 - Chain Complex Congruence","text":"Even if slower than the previous method, employing Julia SparseArrays module cames with the benefit of keeping signed representation updated.","category":"page"},{"location":"chainComplexCongruence/#","page":"4.2 - Chain Complex Congruence","title":"4.2 - Chain Complex Congruence","text":"The cellCongruence() method requires an additional input in the name of lo_sign::Array{Array{Int8,1},1} that is complementary to lo_cls as it holds the sign of the lower order cells. Likewise, an ho_sign is provided as output. In fact, when multiple cells are identified as one, then the new cell is ordered as in Lar standard; therefore, if the old cells were discordelly oriented, then the sign must be changed in the higher order Cochain coherently.","category":"page"},{"location":"chainComplexCongruence/#","page":"4.2 - Chain Complex Congruence","title":"4.2 - Chain Complex Congruence","text":"Do note that points do not come with a sign so when Delta_0 is built, lo_sign is not needed and it is therefore set to one for every vertex:","category":"page"},{"location":"chainComplexCongruence/#","page":"4.2 - Chain Complex Congruence","title":"4.2 - Chain Complex Congruence","text":"lo_sign = [ones(Int8, length(cl)) for cl in lo_cls]","category":"page"},{"location":"chainComplexCongruence/#","page":"4.2 - Chain Complex Congruence","title":"4.2 - Chain Complex Congruence","text":"## 5.2.3 - GraphBlas based implementation","category":"page"},{"location":"chainComplexCongruence/#","page":"4.2 - Chain Complex Congruence","title":"4.2 - Chain Complex Congruence","text":"LC.cellCongruenceGB","category":"page"},{"location":"chainComplexCongruence/#.2.4-Time-and-Space-comparisons-1","page":"4.2 - Chain Complex Congruence","title":"5.2.4 - Time and Space comparisons","text":"","category":"section"},{"location":"#LocalCongruence.jl-1","page":"1 - Home","title":"1 - LocalCongruence.jl","text":"","category":"section"},{"location":"#","page":"1 - Home","title":"1 - Home","text":"LocalCongruence.jl is a Julia library that provides tools for managing local congruences of Chain Complexes.","category":"page"},{"location":"#","page":"1 - Home","title":"1 - Home","text":"The algorithms here presented are all official variation of those we proposed in Local congruence of chain complexes.","category":"page"},{"location":"#","page":"1 - Home","title":"1 - Home","text":"In particular, given a set of local chain complexes in LinearAlgebraicRepresentation standars, this Julia Module compute a the single corresponding global complex using epsilon-congruence of cells, solving topologically the numerical inaccuracies of floating-point arithmetics.","category":"page"},{"location":"#","page":"1 - Home","title":"1 - Home","text":"The code is currently working as part of the Lar.Arrangment workflow. ","category":"page"},{"location":"#Dependencies-1","page":"1 - Home","title":"Dependencies","text":"","category":"section"},{"location":"#","page":"1 - Home","title":"1 - Home","text":"LocalCongruence.jl has the following dependeces:","category":"page"},{"location":"#","page":"1 - Home","title":"1 - Home","text":"DataStructures.jl\nGraphBLASInterface.jl\nLinearAlgebraicRepresentation\nNearestNeighbors.jl\nSparseArrays.jl\nSparseMM.jl\nSuiteSparseGraphBLAS","category":"page"},{"location":"#","page":"1 - Home","title":"1 - Home","text":"In addition CVD-Lab provides also ViewerGL, an OpenGL 3D interactive viewer adopted in the examples of this module","category":"page"},{"location":"#Installing-1","page":"1 - Home","title":"Installing","text":"","category":"section"},{"location":"#","page":"1 - Home","title":"1 - Home","text":"]add https://github.com/cvdlab/LocalCongruence.jl","category":"page"},{"location":"#Docstrings-conventions-1","page":"1 - Home","title":"Docstrings conventions","text":"","category":"section"},{"location":"#","page":"1 - Home","title":"1 - Home","text":"Bold is used to point out theory concepts.\nMonospace is used for everything code related.","category":"page"}]
}
