<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>5.2 - Chain Complex Congruence · LocalCongruence.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/LocalCongruence.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="LocalCongruence.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">LocalCongruence.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">1 - Home</a></li><li><a class="tocitem" href="../start/">2 - Getting Started</a></li><li><a class="tocitem" href="../theory/">3 - Complexes and Chain Operators</a></li><li><a class="tocitem" href="../graph_blas/">4 - Graph Blas Introduction</a></li><li><span class="tocitem">Cell Congruence Enabling</span><ul><li><a class="tocitem" href="../verticesCongruence/">5.1 - Vertices Congruence</a></li><li class="is-active"><a class="tocitem" href>5.2 - Chain Complex Congruence</a><ul class="internal"><li><a class="tocitem" href="#.2.4-Time-and-Space-comparisons-1"><span>5.2.4 - Time and Space comparisons</span></a></li></ul></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../example_1/">6.1 - Cube Grids</a></li><li><a class="tocitem" href="../example_2/">6.2 - ...</a></li><li><a class="tocitem" href="../example_3/">6.3 - ...</a></li></ul></li><li><a class="tocitem" href="../authors/">A - About the Authors</a></li><li><a class="tocitem" href="../bibliography/">B - Bibliography</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Cell Congruence Enabling</a></li><li class="is-active"><a href>5.2 - Chain Complex Congruence</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>5.2 - Chain Complex Congruence</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/cvdlab/LocalCongruence.jl/blob/master/docs/src/chainComplexCongruence.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id=".2-Chain-Complex-Congruence-1"><a class="docs-heading-anchor" href="#.2-Chain-Complex-Congruence-1">5.2 - Chain Complex Congruence</a><a class="docs-heading-anchor-permalink" href="#.2-Chain-Complex-Congruence-1" title="Permalink"></a></h1><p>Once the <strong>Geometry</strong> of the model has been arranged, <strong>Topology</strong> must be updated as well. As from <code>Lar</code> standards Topology is managed as Cochain Operators</p><p><code>vertCongruence()</code> method provides both the new Geometry set and the map that maps old vertices in newly born ones. This is what we refer to <code>lower_order_classes</code> w.r.t. <span>$[\Delta_0]$</span>, the 1-Cochain operator matrix (in short <code>lo_cls</code>). This map, built as a Julia <code>Array{Array{Int,1},1}</code>, is needed when building <span>$[\delta_0]$</span>. In particular, the <code>cellCongruence()</code> for <span>$[\Delta_k]$</span> produces both <span>$\[delta_k]$</span> and a map for cell classes that behaves like the one produced by <code>vertCongruence()</code>: this way the same method can be employed iterativelly over all the Cochain Operators, from the lowest degree up to the hihest.</p><p>Under general setting, given a Cochain operator <span>$[\Delta_k] : C_{k-1} \to C_k$</span> and a <code>lo_cls</code> map steps are needed:</p><ol><li><span>$C_{k-1}$</span> cells are identified with their new representative index</li></ol><p>according the mapping <code>lo_cls</code>.</p><ol><li><span>$C_k$</span> cells are purged from duplicates cells <span>$C_{k-1}$</span>.</li></ol><pre><code class="language-none">If this occurres then the corresponding cell topology has changed and this
follows from low resolution problems.
* If a cell results in having less than ``k + 2`` elements, then it is
  discarded since it has been assimilated in lower order cells. 
* Due to low resolution problems topological gift wrapping (TGW) algorithm
  may be required on ``\{C_k\}_{k&gt;1}`` since new cell may have been formed.</code></pre><ol><li><span>$C_k$</span> cells are compared and duplicates are removed.</li><li>A map <code>ho_cls</code> (we refer to it as <em>higher order</em> in contrast with <code>lo_cls</code>)</li></ol><pre><code class="language-none">between ``C_k`` of ``[\Delta_k]`` and the survivors from previous step
is built.</code></pre><p>In the original use case of the <code>Arrangment</code> pipeline the Cochain Operator Matrices <span>$[\Delta_k]$</span> providden as input have values accumulated on the diagonal as shown in Figure 1. In this case string conditions are likelly to be required: <em>e.g.</em> only points from diffenet complexes are possibly merged.</p><p><img src="./images/nestedMatrix.png" alt/></p><blockquote><p><strong>Figure 1:</strong> Doubly nested structure of sparse block-matrices <span>$[\Delta_k] : C_{k-1} \to C_k$</span>. Here light gray portions identify the originally arranged complexes that are merged toghether. Dark grey portions are instead the cells within the same complex and are the only portions where values are stored.</p></blockquote><p>Three implementation are provided in this package.</p><p>## 5.2.1 - Array of Array based implementation</p><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>LC.cellCongruenceAA</code>. Check Documenter&#39;s build log for details.</p></div></div><p>## 5.2.2 - Native Julia Sparse Matrices based implementation</p><article class="docstring"><header><a class="docstring-binding" id="LocalCongruence.cellCongruenceSM" href="#LocalCongruence.cellCongruenceSM"><code>LocalCongruence.cellCongruenceSM</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">cellCongruenceSM(
	cop::Lar.ChainOp,
	lo_cls::Array{Array{Int,1},1},
	lo_sign::Array{Array{Int8,1},1};
	imp = false,
	d = 0
)::Tuple{ Lar.ChainOp,  Array{Array{Int,1},1},  Array{Array{Int8,1},1} }</code></pre><p>Evaluates the Cell Congruence for a Cochain <span>$cop$</span> with classes <span>$lo_cls$</span>.</p><p>The function determines the new Cochain Operator built from <span>$cop$</span> where the lower order cells are merged according to <span>$lo_cls$</span> map. <span>$lo_sign$</span> specifies whether a cell must be considered in reverse order.</p><p>If optional paramenter <span>$imp$</span> is set to <span>$true$</span> then FP imprecisions are taken into account in the sense that lower order cells may have collided. The parameter <span>$d$</span> represent then the order of the cell (that also is the least number of lower order cells a current order cell is made of).</p><p>The method returns:</p><ul><li>the new Cochain Operator</li><li>a map that, for every new cell, identifies the old cells it is made of</li><li>a map that, for every new cell, specify if old cells have changed ordering.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cvdlab/LocalCongruence.jl/blob/b943d65bee0037042e7788c416937eacbb85be62/src/cea-SM.jl#L3-L27">source</a></section></article><p>Even if slower than the previous method, employing Julia <code>SparseArrays</code> module cames with the benefit of keeping signed representation updated.</p><p>The <code>cellCongruence()</code> method requires an additional input in the name of <code>lo_sign::Array{Array{Int8,1},1}</code> that is complementary to <code>lo_cls</code> as it holds the sign of the lower order cells. Likewise, an <code>ho_sign</code> is provided as output. In fact, when multiple cells are identified as one, then the new cell is ordered as in Lar standard; therefore, if the old cells were discordelly oriented, then the sign must be changed in the higher order Cochain coherently.</p><p>Do note that points do not come with a sign so when <span>$[\Delta_0]$</span> is built, <code>lo_sign</code> is not needed and it is therefore set to one for every vertex:</p><pre><code class="language-julia">lo_sign = [ones(Int8, length(cl)) for cl in lo_cls]</code></pre><p>## 5.2.3 - <code>GraphBlas</code> based implementation</p><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>LC.cellCongruenceGB</code>. Check Documenter&#39;s build log for details.</p></div></div><h2 id=".2.4-Time-and-Space-comparisons-1"><a class="docs-heading-anchor" href="#.2.4-Time-and-Space-comparisons-1">5.2.4 - Time and Space comparisons</a><a class="docs-heading-anchor-permalink" href="#.2.4-Time-and-Space-comparisons-1" title="Permalink"></a></h2></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../verticesCongruence/">« 5.1 - Vertices Congruence</a><a class="docs-footer-nextpage" href="../example_1/">6.1 - Cube Grids »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 2 April 2020 10:46">Thursday 2 April 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
